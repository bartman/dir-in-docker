#!/usr/bin/env bash
set -eu

SELF="$(realpath $0)"
SELFDIR="$(dirname "${SELF}")"
SELF="${SELF##*/}"

WORKDIR="$(pwd)"
PROJNAME="$(basename "$WORKDIR")"
TARGET=
XENABLE=false
PERFENABLE=false
NETENABLE=false
EXTRA_VOLUMES=( )
EXTRA_PACKAGES=( )

LCL_DOCKERFILE_DIR=$(realpath ${WORKDIR})
SYS_DOCKERFILE_DIR=$(realpath ${SELFDIR}/dockerfiles)

HOSTNAME="$(hostname)"
USERNAME="$(id -u -n)"
USER_UID="$(id -u)"
USER_GID="$(id -g)"

# terminal colors
BLACK='\033[0;30m' RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[0;33m' BLUE='\033[0;34m' MAGENTA='\033[0;35m' CYAN='\033[0;36m' WHITE='\033[0;37m'
BRIGHT_BLACK='\033[1;30m' BRIGHT_RED='\033[1;31m' BRIGHT_GREEN='\033[1;32m' BRIGHT_YELLOW='\033[1;33m' BRIGHT_BLUE='\033[1;34m' BRIGHT_MAGENTA='\033[1;35m' BRIGHT_CYAN='\033[1;36m' BRIGHT_WHITE='\033[1;37m'
RESET='\033[0m'

function die {
    echo -e >&2 "${BRIGHT_RED}ERROR: $*${RESET}"
    exit 1
}

function warn {
    echo -e >&2 "${BRIGHT_YELLOW}WARNING: $*${RESET}"
}

function available_targets {
    local -A seen
    for dir in "$LCL_DOCKERFILE_DIR" "$SYS_DOCKERFILE_DIR" ; do
        find "$dir" -maxdepth 1 -name '*.Dockerfile' -printf '%f\n' | while read filename ; do
            local name="${filename%.Dockerfile}"
            [ -v "seen[$name]" ] && continue
            seen[$name]=1
            echo "$name"
        done
    done
}
function default_target {
    available_targets | head -n1
}
function dockerfile_for {
    local target="$1"
    local possible=(
        "$LCL_DOCKERFILE_DIR/${target}.Dockerfile"
        "$SYS_DOCKERFILE_DIR/${target}.Dockerfile"
    )
    for try in "${possible[@]}" ; do
        [ -f "$try" ] || continue
        echo "$try"
        return
    done
}

declare TARGET= DOCKERFILE= FULLNAME=

function derive_target_project_variables {
    [ -z "$TARGET" ] && TARGET="$(default_target)"
    [ -z "$TARGET" ] && die "No targets found; see documentation."
    DOCKERFILE="$(dockerfile_for "$TARGET")"
    [ -f "$DOCKERFILE" ] || die "$DOCKERFILE: no such file"
    [ -r "$DOCKERFILE" ] || die "$DOCKERFILE: cannot be read"
    FULLNAME="DID-${PROJNAME}-for-$USERNAME-on-$TARGET"
    FULLNAME="$(tr 'A-Z' 'a-z' <<<"$FULLNAME")"
}

declare -a BUILD_ARGS=()

function set_build_args {
    local value

    # transfer host user.email to docker
    value="$(git config user.email)"
    [ -z "$value" ] && value="$USERNAME@$HOSTNAME"
    [ -n "$value" ] && BUILD_ARGS+=( "--build-arg=GIT_EMAIL=$value" )

    # transfer host user.name to docker
    value="$(git config user.name)"
    [ -z "$value" ] && value="$USERNAME"
    [ -n "$value" ] && BUILD_ARGS+=( "--build-arg=GIT_NAME=$value" )

    # Add WORKDIR, UID, GID, and USERNAME as build arguments to match host user
    BUILD_ARGS+=( "--build-arg=WORKDIR=$WORKDIR" )
    BUILD_ARGS+=( "--build-arg=UID=$USER_UID" )
    BUILD_ARGS+=( "--build-arg=GID=$USER_GID" )
    BUILD_ARGS+=( "--build-arg=USERNAME=$USERNAME" )

    # Capture other useful environment variables
    local extra_env=
    for var in TERM EDITOR VISUAL LANG FULLNAME ; do
        [[ ${!var+x} ]] || continue
        local val="${!var}"
        if [ -n "$val" ] ; then
            [ -n "${extra_env}" ] && extra_env+=' '
            extra_env+="$var=\"$val\""
        fi
    done
    echo "# extra_env: ${extra_env}"
    BUILD_ARGS+=( "--build-arg=EXTRA_ENV=${extra_env}" )

    # build a list of extra packages to install
    $XENABLE && EXTRA_PACKAGES+=( xauth )

    BUILD_ARGS+=( "--build-arg=EXTRA_PACKAGES=${EXTRA_PACKAGES[*]}" )
}

function show_status {
    local images=( $( docker images | awk "\$1 == \"${FULLNAME}\" { print \$3 }" ) )
    if [ "${#images[@]}" -gt 0 ] ; then
        echo -e "${FULLNAME}: image is ${BRIGHT_GREEN}built${RESET}:    ${BRIGHT_BLUE}${images[*]}${RESET}"
    else
        echo -e "${FULLNAME}: image is ${BRIGHT_RED}not built${RESET}."
    fi

    # Check if container is running
    local running=( $( docker ps | awk "\$2 == \"${FULLNAME}\" { print \$1 }" ) )
    if [ "${#running[@]}" -gt 0 ] ; then
        echo -e "${FULLNAME}: cntnr is ${BRIGHT_GREEN}running${RESET}:  ${BRIGHT_BLUE}${running[*]}${RESET}"
    fi

    local stopped=( $( docker ps --all | awk "\$2 == \"${FULLNAME}\" && /Exited / { print \$1 }" ) )
    if [ "${#stopped[@]}" -gt 0 ] ; then
        echo -e "${FULLNAME}: cntnr is ${BRIGHT_YELLOW}stopped${RESET}:  ${BRIGHT_BLUE}${stopped[*]}${RESET}"
    fi

    if [ "${#running[@]}" -eq 0 ] && [ "${#stopped[@]}" -eq 0 ] ; then
        echo -e "${FULLNAME}: cntnr does ${BRIGHT_RED}not exist${RESET}."
    fi
}

# Function to display help
show_help() {
    cat <<END
${SELF} [ [options] <command> [command-options] ] [ , ... ]

    Options:

        -t <target>    - target to use, default: $(default_target)
        -n <name>      - name to use, default: ${PROJNAME}

        -d <dir>       - [build] local *.Dockerfile location, default:
                           ${LCL_DOCKERFILE_DIR}
        -D <dir>       - [build] system *.Dockerfile location, default:
                           ${SYS_DOCKERFILE_DIR}
        -p <pkg>       - [build] add this package to the build

        -v <dir>       - [start] make this path also visible in container
        -N             - [start] enable host networking
        -P             - [start] enable perf in docker
        -X             - [start] enable X forwarding

    Available commands:

        build          - create a dev image
        remove         - remove a dev image
        start          - start the container
        stop           - stop the container
        status         - check if built/running
        connect        - get a shell in the container
        run     <cmd>  - run a command in the container

        , used to separate multiple commands

    Available targets:

END
    for t in $(available_targets); do
        printf "        %-20s   - %s\n" "$t" "$(dockerfile_for "$t")"
    done
    echo
}

function assert_no_more_arguments {
    local cmd="$1"
    local cnt="$2"
    [[ $cnt = 0 ]] || die "$cmd did not expect additional arguments, found $cnt"
}

function cmd_dispatch {
    local cmd="$1" ; shift

    case "$cmd" in
        help|--help|-h)
            show_help
            exit 0
            ;;
        *,*)
            re="^[a-z,]+$"
            [[ "$cmd" =~ $re ]] || die "bad"
            for x in ${cmd//,/ } ; do
                echo -e >&2 "# ${BRIGHT_YELLOW}$0 $x $*${RESET}"
                if ! "$SELFDIR/$SELF" "-t=$TARGET" "-p=$PROJNAME" "$x" "$@" ; then
                    die "failed: $0 $x $*"
                fi
            done
            exit 0
            ;;
        build)
            derive_target_project_variables
            set_build_args
            ( set -x
            docker build "${@}" "${BUILD_ARGS[@]}" --tag "${FULLNAME}" --file "${DOCKERFILE}" .
            )
            return $?
            ;;
        rm|remove)
            assert_no_more_arguments $cmd $#
            derive_target_project_variables
            ( set -x
            docker image rm --force "${FULLNAME}"
            )
            return $?
            ;;
        up|start)
            assert_no_more_arguments $cmd $#
            derive_target_project_variables
            XARGS=( )
            if $XENABLE ; then
                XARGS+=( --env "DISPLAY=$DISPLAY" --volume "/tmp/.X11-unix:/tmp/.X11-unix" )
                ( set -x
                xhost +local:docker
                )
            fi

            $NETENABLE && XARGS+=( --net=host )

            if $PERFENABLE ; then

                XARGS+=( --cap-add=PERFMON )
            fi

            for v in "${EXTRA_VOLUMES[@]}" ; do
                XARGS+=( --volume "$v:$v" )
            done
            ( set -x
            docker run --detach --init --volume "$WORKDIR:$WORKDIR" --user "$USER_UID:$USER_GID" --name "${FULLNAME}" "${XARGS[@]}" "${FULLNAME}"
            )
            return $?
            ;;
        down|stop)
            assert_no_more_arguments $cmd $#
            derive_target_project_variables
            container_ids=( $(docker ps --all --filter "name=${FULLNAME}" --format='{{.ID}}') )
            if [ "${#container_ids[@]}" = 0 ]; then
                echo "Container ${FULLNAME} is not running."
            else
                if $XENABLE ; then
                    ( set -x
                    xhost -local:docker
                    )
                fi
                for container_id in "${container_ids[@]}" ; do
                    ( set -x
                    docker stop "$container_id"
                    )
                done
                for container_id in "${container_ids[@]}" ; do
                    ( set -x
                    docker rm "$container_id"
                    )
                done
            fi
            return 0
            ;;
        status)
            assert_no_more_arguments $cmd $#
            if [ -n "$TARGET" ] ; then
                derive_target_project_variables
                show_status
                exit $?
            fi
            for t in $(available_targets) ; do
                TARGET="$t"
                derive_target_project_variables
                show_status
                echo
            done
            return 0
            ;;
        connect|enter)
            assert_no_more_arguments $cmd $#
            derive_target_project_variables
            container_id="$(docker ps --all --filter "name=${FULLNAME}" --format='{{.ID}}')"
            if [ -z "$container_id" ]; then
                echo "Container ${FULLNAME} is not running."
            else
                ( set -x
                docker exec -it "$container_id" bash -l
                )
            fi
            return 0
            ;;
        run|exec)
            derive_target_project_variables
            container_id="$(docker ps --all --filter "name=${FULLNAME}" --format='{{.ID}}')"
            if [ -z "$container_id" ]; then
                echo "Container ${FULLNAME} is not running."
                exit 1
            elif [ $# -eq 0 ]; then
                echo "No command provided to run in the container."
                exit 1
            else
                ( set -x
                docker exec --interactive --workdir "${WORKDIR}" "$container_id" /bin/bash -l -c "$*"
                )
            fi
            return 0
            ;;
        *)
            die "${0##*/} [ build | remove | start | stop | status | connect ] <target>"
            ;;
    esac
}

cmd=
accumulate=( )

while [ "${#@}" -gt 0 ] ; do
    arg="$1" ; shift

    if [ "$arg" = , ] ; then
        cmd_dispatch "$cmd" "${accumulate[@]}" || die "failed: $cmd ${accumulate[*]}"
        cmd=
        continue
    fi

    if [ -n "$cmd" ] ; then
        accumulate+=( "$arg" )
        continue
    fi

    case "$arg" in
        build|rm|remove|up|start|down|stop|status|connect|enter|run|exec)
            cmd="$arg"
            ;;
        -t=*) TARGET="${arg#-t=}" ;;
        -t)   TARGET="$1" ; shift ;;

        -n=*) PROJNAME="${arg#-n=}" ;;
        -n)   PROJNAME="$1" ; shift ;;

        -d=*) LCL_DOCKERFILE_DIR="${arg#-d=}" ;;
        -d)   LCL_DOCKERFILE_DIR="$1" ; shift ;;

        -D=*) SYS_DOCKERFILE_DIR="${arg#-d=}" ;;
        -D)   SYS_DOCKERFILE_DIR="$1" ; shift ;;

        -p=*) EXTRA_PACKAGES+=( "${arg#-p=}" ) ;;
        -p)   EXTRA_PACKAGES+=( "$1" ) ; shift ;;

        -v=*) EXTRA_VOLUMES+=( "${arg#-v=}" ) ;;
        -v)   EXTRA_VOLUMES+=( "$1" ) ; shift ;;

        -N) NETENABLE=true ;;
        -X)   XENABLE=true ;;

        -P)
            case "$( sysctl -n kernel.perf_event_paranoid )" in
                -1) ;;
                *) warn "for perf to work in container, run the following from the host:\n\n\t" \
                    "sudo sysctl -w kernel.perf_event_paranoid=-1\n"
            esac
            PERFENABLE=true
            ;;

        help|--help|-h)
            show_help
            exit 0
            ;;
        *)
            die "unexpected option: $arg"
            ;;
    esac
done

if [ -n "$cmd" ] ; then
    cmd_dispatch "$cmd" "${accumulate[@]}" || die "failed: $cmd ${accumulate[*]}"
fi
